EOF *end of file* 

```c
    char expression[100];
    while (scanf("%s", expression)!=EOF) {
        value (expression);
    }
```

上例中每次读取到`\n`时停止，（`\n`也会录入）
## `\0`和`\n`
输入
```
123*+68/-
931-3*+82/+
```
为
```
123*+68/-\0\n
931-3*+82/+\0\n
```
因为当`scanf`录入字符串的时候会自动在字符串末尾增加`'\0'`（`strlen()`检测字符串长度就是根据`'\0'`停止的）；而`getchar()`就不会添加`\0`，所以有时候检测用这种方法录入的字符串长度会从内存中继续向后查找直到`\0`从而得到奇怪的数。

同时要注意循环时，如果像上面输入那么判断为`\n`时会多循环一次：
```c
	for (i=0;expression[i]!='\n';i++) {
```

## EOF
如果想在控制台中结束文档流：
- win中ctrl+z（^Z），则读到的值就是EOF；在linux中是ctrl+d
- 如果是像这样输入：abc^Zefg，然后再回车，将内容通过`getchar()`输入则读到的字符内容是abc^Z，其中^Z是一个无法显示的特殊字符，**而不再是EOF**，包括后面的内容以及最后按下回车输入的不可见的换行符都将被清空。

读到EOF有三种写法，效果是一样的：
```c
scanf("%d", &n)!=EOF;
```
```c
~scanf("%d", &n);
```
```c
scanf("%d", &n)==1;
```

**C++中不存在这种用法**，但是相同作用的有while(cin>>)

**scanf("%d%d", &a, &b);**  
如果a和b都被成功读入，那么scanf的返回值就是2；如果只有a被成功读入，返回值为1；如果a和b都未被成功读入，返回值为0；如果遇到错误或遇到end of file，返回值为EOF，且返回值为int型。